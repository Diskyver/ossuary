<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `ossuary` crate."><meta name="keywords" content="rust, rustlang, rust-lang, ossuary"><title>ossuary - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../ossuary/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate ossuary</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all ossuary's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'ossuary', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span></span><span class='in-band'>Crate <a class="mod" href=''>ossuary</a></span></h1><div class='docblock'><h1 id="ossuary" class="section-header"><a href="#ossuary">Ossuary</a></h1>
<p>Ossuary is a Rust library for establishing an encrypted and
authenticated communication channel between a client and a server.</p>
<p>It establishes a 1-to-1 client/server communication channel that requires
reliable, in-order packet delivery, such as provided by TCP sockets.</p>
<p>Authentication and verification of remote hosts is optional, and requires
an out-of-band exchange of host public keys, or a Trust-On-First-Use policy.</p>
<p>Ossuary includes a C FFI API, and can be built as a native dynamic or static
library for linking into C or C++ binaries.</p>
<h2 id="protocol-overview" class="section-header"><a href="#protocol-overview">Protocol Overview:</a></h2>
<p>The Ossuary protocol consists of two distinct stages: a handshaking stage
and an established channel stage.</p>
<h2 id="handshake" class="section-header"><a href="#handshake">Handshake</a></h2>
<p>All connections begin by handshaking.  A few packets are exchanged back and
forth to establish an encrypted channel with a negotiated session key, and
to optionally authenticate the identity of the hosts.  Handshake packets are
generated by the Ossuary library itself; the application asks Ossuary for
the next packet to send, and then is responsible for putting it on the wire.</p>
<h2 id="established-channel" class="section-header"><a href="#established-channel">Established Channel</a></h2>
<p>Once the handshake completes successfully, Ossuary drops into the
established channel stage.  In this stage, Ossuary is completely passive,
where the application gives it data to encrypt for transmission or decrypt
for reception.  Ossuary does not generate any unrequested packets in this
stage.</p>
<p>In the case of errors, Ossuary always terminates the encrypted channel and
drops back into the handshake stage.  If it believes the channel might still
be viable, the handshake stage will generate a packet to attempt to reset
the remote host back into the handshake as well, and they will both attempt
to recover the channel.</p>
<h2 id="api-overview" class="section-header"><a href="#api-overview">API Overview:</a></h2>
<p>Ossuary fits into an application as a 'filter' on network traffic, and does
not implement any network communication itself.  Similarly, it does not have
any persistent storage, leaving the storage of keys to the caller.</p>
<p>The application must always check to see if it should drop back into the
handshake, in case the connection failed.  The main loop would typically be
split between two cases: handshaking, or established channel.</p>
<p>In pseudocode, typical use of the API looks like this:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="kw">fn</span> <span class="ident">main</span>() {
  <span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">TCPSocket</span>::<span class="ident">get_socket_from_somewhere</span>();
  <span class="kw">let</span> <span class="ident">secret_key</span> <span class="op">=</span> <span class="ident">FileSystem</span>::<span class="ident">get_securely_stored_file</span>(<span class="string">&quot;secret.key&quot;</span>);
  <span class="kw">let</span> <span class="ident">ossuary</span> <span class="op">=</span> <span class="ident">OssuaryConnection</span>::<span class="ident">new</span>(<span class="ident">ConnectionType</span>::<span class="ident">Whatever</span>, <span class="prelude-val">Some</span>(<span class="ident">secret_key</span>));
  <span class="kw">let</span> <span class="ident">net_read_buf</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">1024</span>];  <span class="comment">// encrypted!</span>
  <span class="kw">let</span> <span class="ident">net_write_buf</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">1024</span>]; <span class="comment">// encrypted!</span>
  <span class="kw">let</span> <span class="ident">internal_buf</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">1024</span>];  <span class="comment">// plaintext!</span>

  <span class="kw">loop</span> {
    <span class="comment">// Always read encrypted data off the wire and append to our read buf</span>
    <span class="ident">socket</span>.<span class="ident">read_and_append</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">net_read_buf</span>);

    <span class="comment">// Two paths depending on if we are handshaking</span>
    <span class="kw">match</span> <span class="ident">ossuary</span>.<span class="ident">handshake_done</span>() {
      <span class="bool-val">false</span> <span class="op">=&gt;</span> {
        <span class="comment">// Parse received handshake packets.</span>
        <span class="ident">ossuary</span>.<span class="ident">recv_handshake</span>(<span class="kw-2">&amp;</span><span class="ident">net_read_buf</span>);

        <span class="comment">// Possibly write handshake packets.</span>
        <span class="ident">ossuary</span>.<span class="ident">send_handshake</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">net_write_buf</span>);
      },

      <span class="bool-val">true</span> <span class="op">=&gt;</span> {
        <span class="comment">// Decrypt data into internal buffer</span>
        <span class="ident">ossuary</span>.<span class="ident">recv_data</span>(<span class="kw-2">&amp;</span><span class="ident">net_read_buf</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">internal_buf</span>);

        <span class="comment">// Do some application-specific thing with the data</span>
        <span class="ident">react_and_respond</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">internal_buf</span>);

        <span class="comment">// Encrypt application&#39;s response</span>
        <span class="ident">ossuary</span>.<span class="ident">send_data</span>(<span class="kw-2">&amp;</span><span class="ident">internal_buf</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">net_write_buf</span>);
      },
    }

    <span class="comment">// Always write all encrypted data onto the wire and clear the write buf</span>
    <span class="ident">socket</span>.<span class="ident">write_and_clear</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">net_write_buf</span>);
  }
}</pre></div>
<p>A real implementation would also need to carefully handle removing consumed
bytes from the read buffer, and handling errors at every step.</p>
<p>Since Ossuary leaves the actual wire transmission to the caller, it can be
used over any physical channel, or with any transmission protocol, so long
as data is delivered (to Ossuary) reliably and in-order.  It is just as
viable for UNIX Domain Sockets, D-Bus, named pipes, and other IPC mechanisms
as for TCP, if you somehow have a threat model that distrusts those.</p>
<h2 id="ciphers" class="section-header"><a href="#ciphers">Ciphers:</a></h2>
<ul>
<li>Ephemeral session keys: Curve25519 ECDH.</li>
<li>Session encryption: ChaCha20 symmetrical cipher.</li>
<li>Message authentication: Poly1305 MAC.</li>
<li>Host authentication: Ed25519 signature scheme.</li>
</ul>
<h2 id="the-handshake-protocol" class="section-header"><a href="#the-handshake-protocol">The handshake protocol:</a></h2>
<p>A 3-packet (1.5 roundtrip) handshake is always performed.</p>
<p>The necessary fields to perform an ECDH key exchange and establish a
shared session key are sent in the clear, while fields for host verification
are encrypted with the established session key.</p>
<p>In the following diagram, fields in [single brackets] are sent in the clear,
and those in [[double brackets]] are encrypted with the shared session key:</p>
<pre><code class="language-text">&lt;client&gt; --&gt; [  session x25519 public key,
                session nonce,
                client random challenge                ] --&gt; &lt;server&gt;
&lt;client&gt; &lt;-- [  session x25519 public key,
                session nonce],
             [[ auth ed25519 public key,
                server random challenge,
                signature(pubkey, nonce, challenge),  ]] &lt;-- &lt;server&gt;
&lt;client&gt; --&gt; [[ auth ed25519 public key,
                signature(pubkey, nonce, challenge),  ]] --&gt; &lt;server&gt;
</code></pre>
<p>Host authentication (verifying the identity of the remote server or client)
is optional.   In non-authenticated flows, &quot;auth public key&quot;, &quot;challenge&quot;,
and &quot;signature&quot; fields are set to all 0s, but are still transmitted.</p>
<h3 id="fields" class="section-header"><a href="#fields">Fields</a></h3>
<ul>
<li><strong>session public key</strong>: Public part of randomly generated public/private
key pair for this session, used to generate an ephemeral session key.</li>
<li><strong>challenge</strong>: Randomly generated string for remote party to sign to prove
its identity in authenticated connections.</li>
<li><strong>auth public key</strong>: Public part of long-lived public/private key pair
used for host authentication.</li>
<li><strong>signature</strong>: Signature, with long-lived private authentication key, of
local party's session public key and nonce (the ECDH parameters) and
remote party's random challenge, to prove host identity and prevent
man-in-the-middle attacks.</li>
</ul>
<h2 id="security-protections" class="section-header"><a href="#security-protections">Security Protections</a></h2><h3 id="passive-snooping" class="section-header"><a href="#passive-snooping">Passive Snooping</a></h3>
<p>Per-packet encryption with ChaCha20 prevents passive monitoring of the
contents of the communication channel.</p>
<h3 id="malleability" class="section-header"><a href="#malleability">Malleability</a></h3>
<p>Poly1305 MAC prevents active manipulation of packets in-flight, ensuring
that any manipulation will cause the channel to terminate.</p>
<h3 id="replay-attacks" class="section-header"><a href="#replay-attacks">Replay Attacks</a></h3>
<p>Poly1305 MAC combined with a nonce scheme prevents replay attacks, and
prevents manipulation of message order.</p>
<h3 id="forward-secrecy" class="section-header"><a href="#forward-secrecy">Forward Secrecy</a></h3>
<p>Per-session encryption with ephemeral x25519 keys ensures that the
compromise of one session does not necessarily result in the compromise of
any previous or future session.</p>
<h3 id="man-in-the-middle" class="section-header"><a href="#man-in-the-middle">Man-in-the-Middle</a></h3>
<p>Host authentication with Ed25519 signature verification of ECDH parameters
prevents man-in-the-middle attacks.  Host authentication is optional, and
requires out-of-band exchange of host public keys or a Trust On First Use
policy, so MITM attacks may be possible if care is not taken.</p>
<h2 id="security-limitations" class="section-header"><a href="#security-limitations">Security Limitations</a></h2><h3 id="code-quality" class="section-header"><a href="#code-quality">Code Quality</a></h3>
<p>This software is not code reviewed, and no security analysis has been
performed.</p>
<h3 id="keys-in-ram" class="section-header"><a href="#keys-in-ram">Keys In RAM</a></h3>
<p>No efforts are taken to secure key data in RAM.  Attacks from privileged
local processes are possible.</p>
<h3 id="keys-on-disk" class="section-header"><a href="#keys-on-disk">Keys On Disk</a></h3>
<p>No mechanisms are provided for storing keys on disk.  Secure key storage
is left as a task for the caller.</p>
<h3 id="side-channel" class="section-header"><a href="#side-channel">Side-Channel</a></h3>
<p>No efforts are taken to protect against side channel attacks such as timing
or cache analysis.</p>
<h3 id="software-dependencies" class="section-header"><a href="#software-dependencies">Software Dependencies</a></h3>
<p>This software depends on third-party software libraries for all core
cryptographic algorithms, which have not been code reviewed and are subject
to change.</p>
<h3 id="trust-on-first-use-tofu" class="section-header"><a href="#trust-on-first-use-tofu">Trust-On-First-Use (TOFU)</a></h3>
<p>Host authentication supports a trust-on-first-use policy, which opens the
possibility of man-in-the-middle attacks if the first connection is
compromised.</p>
<h1 id="license" class="section-header"><a href="#license">License</a></h1>
<p>Copyright 2019 Trevor Bentley</p>
<p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at</p>
<p>http://www.apache.org/licenses/LICENSE-2.0</p>
<p>Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</p>
</div><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="clib/index.html" title='ossuary::clib mod'>clib</a></td><td class='docblock-short'><p>Ossuary API exposed with a C FFI</p>
</td></tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.OssuaryConnection.html" title='ossuary::OssuaryConnection struct'>OssuaryConnection</a></td><td class='docblock-short'><p>Context for interacting with an encrypted communication channel</p>
</td></tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table><tr class='module-item'><td><a class="enum" href="enum.ConnectionType.html" title='ossuary::ConnectionType enum'>ConnectionType</a></td><td class='docblock-short'><p>Enum specifying the client or server role of a <a href="../ossuary/struct.OssuaryConnection.html" title="`OssuaryConnection`"><code>OssuaryConnection</code></a></p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.OssuaryError.html" title='ossuary::OssuaryError enum'>OssuaryError</a></td><td class='docblock-short'><p>Error produced by Ossuary or one of its dependencies</p>
</td></tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table><tr class='module-item'><td><a class="fn" href="fn.generate_auth_keypair.html" title='ossuary::generate_auth_keypair fn'>generate_auth_keypair</a></td><td class='docblock-short'><p>Generate secret/public Ed25519 keypair for host authentication</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "ossuary";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>